# Architecture Documentation: E-Commerce Product Dashboard

This document provides a detailed overview of the architectural decisions, code structure, and key components of the E-Commerce Product Dashboard, a web application for managing e-commerce products. Built with React, TypeScript, Vite, and Tailwind CSS, the project emphasizes modularity, maintainability, and user experience, with features for product CRUD operations, search/filtering, bulk deletion, undo delete and local storage persistence.

## Table of Contents

- [Overview](#overview)
- [Architectural Decisions](#architectural-decisions)
  - [Frontend Framework: React with TypeScript](#frontend-framework-react-with-typescript)
  - [Build Tool: Vite](#build-tool-vite)
  - [Styling: Tailwind CSS and Shadcn UI](#styling-tailwind-css-and-shadcn-ui)
  - [State Management: Context API with Reducer](#state-management-context-api-with-reducer)
  - [Routing: React Router](#routing-react-router)
  - [Persistence: Local Storage](#persistence-local-storage)
  - [Notifications: React Toastify](#notifications-react-toastify)
  - [Testing: Jest and React Testing Library](#testing-jest-and-react-testing-library)
- [Project Structure](#project-structure)
- [Component Hierarchy](#component-hierarchy)
- [Key Components and Code](#key-components-and-code)
  - [ProductContext.tsx](#productcontexttsx)
  - [ProductForm.tsx](#productformtsx)
  - [ProductDisplay.tsx](#productdisplaytsx)
  - [ProductCard.tsx](#productcardtsx)
  - [SearchFilters.tsx](#searchfilterstsx)
  - [BulkDeletePage.tsx](#bulkdeletepagetsx)
  - [useLocalStorage.tsx](#uselocalstoragettsx)
- [Data Flow](#data-flow)
- [Testing Strategy](#testing-strategy)

## Overview

The E-Commerce Product Dashboard is a single-page application (SPA) designed for managing product inventory. Users can add, edit, delete, search, and filter products, with data persisted in the browser’s `localStorage`. The application features a responsive, accessible UI with real-time form validation, pagination, toast notifications, and a dedicated bulk delete page. Key architectural goals include:

- **Modularity**: Reusable components and hooks for maintainability.
- **Type Safety**: TypeScript for robust type checking and developer experience.
- **Performance**: Optimized with Vite, memoization, and minimal re-renders.
- **User Experience**: Real-time feedback, accessibility, and intuitive navigation.
- **Testability**: Comprehensive unit tests for critical components.

## Architectural Decisions

### Frontend Framework: React with TypeScript

**Decision**: Chose React for its component-based architecture, ecosystem, and performance. TypeScript was integrated for static type checking, reducing runtime errors and improving code documentation.

**Rationale**:
- React’s declarative UI and hooks enable reusable, composable components (e.g., `ProductCard`, `ProductForm`).
- TypeScript ensures type safety for props (e.g., `ProductCardProps`), context (`ProductContextType`), and state, catching errors during development.
- TypeScript’s interfaces (`Product`, `Filters`) centralize type definitions in `src/types/index.ts`.

**Example**:
```typescript
// src/types/index.ts
export interface Product {
  id: string;
  name: string;
  price: number;
  category: 'Electronics' | 'Clothing' | 'Books' | 'Home' | 'Sports' | 'Other';
  stock: number;
  description: string;
  image?: string;
}
```

### Build Tool: Vite

**Decision**: Used Vite as the build tool for its fast development server and optimized production builds.

**Rationale**:
- Vite’s ES module-based dev server provides near-instant hot module replacement (HMR), improving developer productivity.
- Faster than Create React App due to native ES modules and Rollup-based bundling.
- Supports TypeScript, Tailwind CSS, and React out of the box via `vite.config.ts`.

**Example**:
```typescript
// vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
});
```

### Styling: Tailwind CSS and Shadcn UI

**Decision**: Adopted Tailwind CSS for utility-first styling and Shadcn UI for reusable dialog components.

**Rationale**:
- Tailwind’s utility classes enable rapid, consistent styling without custom CSS (e.g., `bg-white p-6 rounded-lg shadow-md`).
- Reduces CSS bundle size and avoids naming conflicts compared to traditional CSS.
- Shadcn UI’s Dialog component provides accessible, customizable modals for delete and bulk delete confirmations.
- Tailwind configuration (`tailwind.config.js`) includes Shadcn paths for seamless integration.

**Example**:
```tsx
// src/components/ui/dialog.tsx (generated by Shadcn)
import * as DialogPrimitive from '@radix-ui/react-dialog';
import { cn } from '../../lib/utils';

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Content
    ref={ref}
    className={cn(
      'fixed z-50 bg-white p-6 rounded-lg shadow-lg',
      className
    )}
    {...props}
  />
));
```

### State Management: Context API with Reducer

**Decision**: Used React’s Context API with a reducer for centralized state management of products and filters.

**Rationale**:
- Context API is lightweight for a small-scale app, avoiding the overhead of Redux or Zustand.
- A reducer (`productReducer`) manages product CRUD and filter state, ensuring predictable updates.
- `useLocalStorage` hook syncs state with `localStorage`, providing persistence.
- Context (`ProductContext`) exposes methods (`addProduct`, `updateProduct`, `deleteProduct`, `undoDelete`, `bulkDelete`, `setFilters`) to components.

**Example**:
```tsx
// src/context/ProductContext.tsx
const productReducer = (state: ProductState, action: ProductAction): ProductState => {
  switch (action.type) {
    case 'ADD_PRODUCT':
      return { ...state, products: [...state.products, action.payload] };
    case 'DELETE_PRODUCT':
      return {
        ...state,
        products: state.products.filter((p) => p.id !== action.payload),
        deletedProduct: state.products.find((p) => p.id === action.payload) || null,
      };
    case 'BULK_DELETE':
      return {
        ...state,
        products: state.products.filter((p) => !action.payload.includes(p.id)),
        deletedProduct: null,
      };
    // ... other cases
  }
};
```

### Routing: React Router

**Decision**: Implemented client-side routing with React Router for navigation between the dashboard and bulk delete page.

**Rationale**:
- React Router provides a declarative API for SPA routing (`BrowserRouter`, `Routes`, `Route`).
- Supports navigation (`useNavigate`) for the "Bulk Delete" button (`/` to `/bulk-delete`) and back button.
- Minimal routes (`/`, `/bulk-delete`) keep the app simple.

**Example**:
```tsx
// src/App.tsx
function App() {
  return (
    <BrowserRouter>
      <div className="min-h-screen bg-gray-100">
        <Header />
        <main className="container mx-auto p-4">
          <Routes>
            <Route path="/" element={<Dashboard />} />
            <Route path="/bulk-delete" element={<BulkDeletePage />} />
          </Routes>
        </main>
      </div>
    </BrowserRouter>
  );
}
```

### Persistence: Local Storage

**Decision**: Used `localStorage` for product persistence via a custom `useLocalStorage` hook.

**Rationale**:
- `localStorage` provides simple, client-side storage without server dependencies.
- `useLocalStorage` abstracts storage operations, syncing state with `localStorage` on updates.
- Ensures products persist across sessions, ideal for a demo or small-scale app.

**Example**:
```tsx
// src/hooks/useLocalStorage.tsx
function useLocalStorage<T>(key: string, initialValue: T): [T, Dispatch<SetStateAction<T>>] {
  const [value, setValue] = useState<T>(() => {
    const storedValue = localStorage.getItem(key);
    return storedValue ? JSON.parse(storedValue) : initialValue;
  });

  useEffect(() => {
    localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]);

  return [value, setValue];
}
```

### Notifications: React Toastify

**Decision**: Used React Toastify for user feedback notifications.

**Rationale**:
- Provides a customizable, non-intrusive UI for success messages (add, edit, delete, bulk delete).
- Supports interactive toasts (e.g., undo for single deletes via `onClick`).
- Configured with `autoClose: 5000` for temporary visibility.

**Example**:
```tsx
// src/components/dashboard/ProductDisplay.tsx
const handleDeleteConfirm = useCallback(() => {
  if (!productToDelete) return;
  const toastId = toast.success('Product deleted! Click to undo.', {
    onClick: () => {
      undoDelete(productToDelete);
      toast.dismiss(toastId);
    },
    autoClose: 5000,
  });
  deleteProduct(productToDelete.id);
  setProductToDelete(null);
}, [productToDelete, deleteProduct, undoDelete]);
```

### Testing: Jest and React Testing Library

**Decision**: Adopted Jest with React Testing Library for unit testing, focusing on `ProductForm`.

**Rationale**:
- React Testing Library encourages testing user behavior over implementation details.
- Jest’s `ts-jest` preset supports TypeScript with a JSDOM environment.
- `@testing-library/jest-dom` extends matchers (`toBeInTheDocument`, `toHaveValue`).
- Mocks `localStorage`, `react-toastify`, and `ProductContext` for isolation.

**Example**:
```tsx
// src/components/forms/__tests__/ProductForm.test.tsx
it('should successfully add product with valid data', async () => {
  const user = userEvent.setup();
  renderWithContext(<ProductForm />);
  const nameInput = screen.getByLabelText(/product name/i);
  await user.type(nameInput, 'Test Product');
  // ... fill other fields
  fireEvent.click(screen.getByText(/add product/i));
  await waitFor(() => {
    expect(mockContext.addProduct).toHaveBeenCalledWith(
      expect.objectContaining({ name: 'Test Product' })
    );
  });
});
```

## Project Structure

```
ecommerce-dashboard/
├── public/
│   ├── images/
│   │   ├── default-product.jpg
├── src/
│   ├── components/
│   │   ├── common/
│   │   │   ├── ErrorBoundary.tsx
│   │   │   ├── Header.tsx
│   │   ├── forms/
│   │   │   ├── ProductForm.tsx
│   │   │   ├── SearchFilters.tsx
│   │   │   ├── __tests__/
│   │   │   │   ├── ProductForm.test.tsx
│   │   ├── product/
│   │   │   ├── ProductCard.tsx
│   │   │   ├── SkeletonCard.tsx
│   │   ├── ui/
│   │   │   ├── button.tsx
│   │   │   ├── dialog.tsx
│   │   ├── dashboard/
│   │   │   ├── ProductDisplay.tsx
│   ├── context/
│   │   ├── ProductContext.tsx
│   ├── hooks/
│   │   ├── useLocalStorage.tsx
│   ├── pages/
│   │   ├── Dashboard.tsx
│   │   ├── BulkDeletePage.tsx
│   ├── types/
│   │   ├── index.ts
│   ├── App.tsx
│   ├── index.css
│   ├── main.tsx
│   ├── setupTests.ts
├── jest.config.js
├── package.json
├── tailwind.config.js
├── tsconfig.json
├── vite.config.ts
├── README.md
├── ARCHITECTURE.md
```

- **public/images/**: Stores static assets like the default product image.
- **src/components/**: Reusable UI components, organized by feature (`forms`, `product`, `dashboard`).
- **src/context/**: Centralized state management with `ProductContext`.
- **src/hooks/**: Custom hooks like `useLocalStorage`.
- **src/pages/**: Route-specific components (`Dashboard`, `BulkDeletePage`).
- **src/types/**: TypeScript interfaces for type safety.
- **src/setupTests.ts**: Jest setup for testing utilities.

## Component Hierarchy

```
App
├── Header
├── Routes
│   ├── Dashboard
│   │   ├── ErrorBoundary
│   │   ├── ProductForm
│   │   ├── SearchFilters
│   │   ├── ProductDisplay
│   │   │   ├── ProductCard (multiple)
│   │   │   ├── SkeletonCard (multiple, during loading)
│   │   │   ├── Dialog (delete confirmation)
│   │   ├── ProductCard (multiple, all products list)
│   ├── BulkDeletePage
│   │   ├── ProductCard (multiple, with checkboxes)
│   │   ├── Dialog (bulk delete confirmation)
```

- **App**: Root component with routing and layout.
- **Header**: Static navigation or branding (minimal implementation).
- **Dashboard**: Main page with form, filters, product list, and display.
- **BulkDeletePage**: Dedicated page for bulk deletion with checkboxes.
- **Dialog**: Reusable Shadcn component for confirmations.

## Key Components and Code

### ProductContext.tsx

**Purpose**: Manages global state for products and filters using Context API and a reducer.

**Key Features**:
- Handles CRUD operations (`addProduct`, `updateProduct`, `deleteProduct`, `undoDelete`, `bulkDelete`).
- Syncs state with `localStorage` via `useLocalStorage`.
- Filters products with `filteredProducts` using `useMemo`.
- Prevents duplicate products in `undoDelete`.

**Code Snippet**:
```tsx
const ProductContext = createContext<ProductContextType | undefined>(undefined);

function ProductProvider({ children }: ProductProviderProps) {
  const [products, setProducts] = useLocalStorage<Product[]>('products', []);
  const [state, dispatch] = useReducer(productReducer, {
    products: [],
    filters: {},
    loading: true,
    deletedProduct: null,
  });

  const bulkDelete = (ids: string[]) => {
    dispatch({ type: 'BULK_DELETE', payload: ids });
    setProducts(products.filter((p) => !ids.includes(p.id)));
  };

  const filteredProducts = useMemo(() => {
    let result = state.products;
    if (state.filters.searchTerm) {
      const term = state.filters.searchTerm.toLowerCase();
      result = result.filter(
        (p) => p.name.toLowerCase().includes(term) || p.description.toLowerCase().includes(term)
      );
    }
    // ... other filters
    return result;
  }, [state.products, state.filters]);

  return (
    <ProductContext.Provider
      value={{
        products: filteredProducts,
        allProducts: state.products,
        loading: state.loading,
        addProduct,
        updateProduct,
        deleteProduct,
        undoDelete,
        setFilters,
        filters: state.filters,
        bulkDelete,
      }}
    >
      {children}
    </ProductContext.Provider>
  );
}
```

**Decision**:
- Reducer ensures predictable state updates.
- `useMemo` optimizes filter calculations.
- Duplicate prevention in `UNDO_DELETE` avoids ID conflicts.

### ProductForm.tsx

**Purpose**: Form for adding/editing products with real-time validation.

**Key Features**:
- Real-time validation on `onChange` and `onBlur` for name, price, stock, description, and image.
- Clears fields on cancel in edit mode.
- Submits via context methods (`addProduct`, `updateProduct`).
- Accessible with ARIA attributes.

**Code Snippet**:
```tsx
function ProductForm({ productToEdit, onCancel }: ProductFormProps) {
  const { addProduct, updateProduct } = useContext(ProductContext)!;
  const [formData, setFormData] = useState<FormData>(
    productToEdit ? { ...productToEdit, price: productToEdit.price.toString(), stock: productToEdit.stock.toString() } : initialState
  );
  const [errors, setErrors] = useState<Partial<FormData>>({});

  const validateField = useCallback((name: keyof FormData, value: string) => {
    const newErrors: Partial<FormData> = {};
    if (name === 'name' && (!value || value.length < 3 || value.length > 50)) {
      newErrors.name = 'Name must be 3-50 characters';
    }
    // ... other validations
    return newErrors;
  }, []);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setFormData((prev) => ({ ...prev, [name as keyof FormData]: value }));
    const fieldErrors = validateField(name as keyof FormData, value);
    setErrors((prev) => ({
      ...prev,
      ...fieldErrors,
      ...(fieldErrors[name as keyof FormData] ? {} : { [name as keyof FormData]: undefined }),
    }));
  };

  return (
    <form onSubmit={handleSubmit} className="bg-white p-6 rounded-lg shadow-md space-y-4">
      <div>
        <label htmlFor="name">Product Name</label>
        <input
          type="text"
          id="name"
          name="name"
          value={formData.name}
          onChange={handleChange}
          onBlur={handleBlur}
          aria-required="true"
          aria-invalid={!!errors.name}
        />
        {errors.name && <p id="name-error" role="alert">{errors.name}</p>}
      </div>
      {/* ... other fields */}
    </form>
  );
}
```

**Decision**:
- Real-time validation improves UX.
- `useCallback` optimizes validation functions.
- ARIA attributes ensure accessibility.

### ProductDisplay.tsx

**Purpose**: Displays paginated product cards with edit/delete actions.

**Key Features**:
- Pagination (9 products per page).
- Three-dot dropdown for edit/delete with outside click handler.
- Delete confirmation via Shadcn Dialog with undo toast.
- Default image (`/images/default-product.jpg`) for products without images.

**Code Snippet**:
```tsx
function ProductDisplay({ setProductToEdit }: ProductDisplayProps) {
  const { products, loading, deleteProduct, undoDelete } = useContext(ProductContext)!;
  const [currentPage, setCurrentPage] = useState(1);
  const [openDropdownId, setOpenDropdownId] = useState<string | null>(null);
  const [productToDelete, setProductToDelete] = useState<Product | null>(null);
  const dropdownRefs = useRef<Map<string, HTMLDivElement>>(new Map());

  const paginatedProducts = useMemo(() => {
    const start = (currentPage - 1) * PRODUCTS_PER_PAGE;
    return products.slice(start, start + PRODUCTS_PER_PAGE);
  }, [products, currentPage]);

  const handleDeleteConfirm = useCallback(() => {
    if (!productToDelete) return;
    const toastId = toast.success('Product deleted! Click to undo.', {
      onClick: () => {
        undoDelete(productToDelete);
        toast.dismiss(toastId);
      },
      autoClose: 5000,
    });
    deleteProduct(productToDelete.id);
    setProductToDelete(null);
  }, [productToDelete, deleteProduct, undoDelete]);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (openDropdownId && !dropdownRefs.current.get(openDropdownId)?.contains(event.target as Node)) {
        setOpenDropdownId(null);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, [openDropdownId]);

  return (
    <div>
      {loading ? <SkeletonCard /> : paginatedProducts.map((product) => (
        <div key={product.id} className="relative">
          <ProductCard product={product} />
          <div className="absolute top-2 right-2">
            <button onClick={() => toggleDropdown(product.id)} aria-label={`Open menu for ${product.name}`}>
              {/* Three-dot icon */}
            </button>
            {openDropdownId === product.id && (
              <div ref={(el) => el && dropdownRefs.current.set(product.id, el)}>
                <button onClick={() => handleEdit(product)}>Edit</button>
                <button onClick={() => handleDeleteRequest(product)}>Delete</button>
              </div>
            )}
          </div>
        </div>
      ))}
      <Dialog open={!!productToDelete} onOpenChange={handleDeleteCancel}>
        <DialogContent>
          <DialogTitle>Delete {productToDelete?.name}?</DialogTitle>
          <Button onClick={handleDeleteConfirm}>Delete</Button>
        </DialogContent>
      </Dialog>
      {/* Pagination buttons */}
    </div>
  );
}
```

**Decision**:
- `useMemo` optimizes pagination.
- `useRef` with `Map` manages dropdown refs for outside click handling.
- Toast dismissal prevents multiple undo actions.

### ProductCard.tsx

**Purpose**: Reusable component for displaying product details.

**Key Features**:
- Displays name, price, category, stock, description, and image.
- Uses local default image (`/images/default-product.jpg`) if no image URL.
- Memoized with `React.memo` for performance.

**Code Snippet**:
```tsx
const ProductCard = ({ product }: ProductCardProps) => {
  return (
    <div className="bg-white border rounded-lg shadow-md p-4">
      <img
        src={product.image || '/images/default-product.jpg'}
        alt={product.name}
        className="w-full h-40 object-cover rounded-md mb-4"
      />
      <h3 className="text-lg font-semibold">{product.name}</h3>
      <p className="text-gray-600">${product.price.toFixed(2)}</p>
      <p className="text-gray-500">Category: {product.category}</p>
      <p className="text-gray-500">Stock: {product.stock}</p>
      <p className="text-gray-500 truncate">{product.description}</p>
    </div>
  );
};

export default memo(ProductCard);
```

**Decision**:
- Static asset in `public/` simplifies image access.
- `memo` prevents unnecessary re-renders.

### SearchFilters.tsx

**Purpose**: Form for filtering products by search term, category, price range, and stock status.

**Key Features**:
- Debounced search and URL param updates with `useSearchParams`.
- Real-time filter updates via `setFilters`.
- Displays active filters and a "Clear Filters" button.

**Code Snippet**:
```tsx
function SearchFilters() {
  const { setFilters, filters } = useContext(ProductContext)!;
  const [searchParams, setSearchParams] = useSearchParams();
  const [searchTerm, setSearchTerm] = useState(searchParams.get('search') || '');

  const debouncedSetFilters = useCallback(
    debounce((newFilters: Filters) => setFilters(newFilters), 300),
    [setFilters]
  );

  const handleFilterChange = useCallback(() => {
    const newFilters: Filters = {
      searchTerm,
      // ... other filters
    };
    debouncedSetFilters(newFilters);
    setSearchParams({
      ...(searchTerm && { search: searchTerm }),
      // ... other params
    }, { replace: true });
  }, [searchTerm, debouncedSetFilters, setSearchParams]);

  return (
    <div className="bg-white p-6 rounded-lg shadow-md mb-4">
      <input
        type="text"
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder="Search by name or description"
      />
      {/* ... other filter inputs */}
      <button onClick={handleClearFilters}>Clear Filters</button>
    </div>
  );
}
```

**Decision**:
- Debouncing with Lodash reduces frequent updates.
- URL params sync filters for shareable links.
- `useCallback` ensures stable handlers.

### BulkDeletePage.tsx

**Purpose**: Dedicated page for bulk deletion with checkboxes and confirmation.

**Key Features**:
- Checkboxes on product cards for selection.
- Conditional "Delete Bulk" button with count.
- Shadcn Dialog for confirmation (no undo).
- Uses `bulkDelete` from context.

**Code Snippet**:
```tsx
function BulkDeletePage() {
  const { allProducts, bulkDelete } = useContext(ProductContext)!;
  const [selectedProducts, setSelectedProducts] = useState<string[]>([]);
  const [isConfirmOpen, setIsConfirmOpen] = useState(false);

  const confirmDelete = useCallback(() => {
    bulkDelete(selectedProducts);
    toast.success(`${selectedProducts.length} product(s) deleted successfully!`);
    setSelectedProducts([]);
    setIsConfirmOpen(false);
  }, [selectedProducts, bulkDelete]);

  return (
    <div>
      {selectedProducts.length > 0 && (
        <Button onClick={() => setIsConfirmOpen(true)}>
          Delete Bulk ({selectedProducts.length})
        </Button>
      )}
      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
        {allProducts.map((product) => (
          <div key={product.id}>
            <input
              type="checkbox"
              checked={selectedProducts.includes(product.id)}
              onChange={() => handleCheckboxChange(product.id)}
            />
            <ProductCard product={product} />
          </div>
        ))}
      </div>
      <Dialog open={isConfirmOpen}>
        <DialogContent>
          <DialogTitle>Delete {selectedProducts.length} Product(s)?</DialogTitle>
          <Button onClick={confirmDelete}>Delete</Button>
        </DialogContent>
      </Dialog>
    </div>
  );
}
```

**Decision**:
- `BULK_DELETE` action ensures atomic multi-deletion.
- No undo aligns with requirements.

### useLocalStorage.tsx

**Purpose**: Custom hook for `localStorage` persistence.

**Key Features**:
- Syncs state with `localStorage` on changes.
- Initializes state from `localStorage` or a default value.

**Code Snippet**:
```tsx
function useLocalStorage<T>(key: string, initialValue: T): [T, Dispatch<SetStateAction<T>>] {
  const [value, setValue] = useState<T>(() => {
    const storedValue = localStorage.getItem(key);
    return storedValue ? JSON.parse(storedValue) : initialValue;
  });

  useEffect(() => {
    localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]);

  return [value, setValue];
}
```

**Decision**:
- Generic type `<T>` supports flexible usage.
- `useEffect` ensures persistence without external libraries.

## Data Flow

1. **Product CRUD**:
   - `ProductForm` submits data to `ProductContext` (`addProduct`, `updateProduct`).
   - `ProductDisplay` triggers `deleteProduct` or `undoDelete` via dropdown.
   - `BulkDeletePage` calls `bulkDelete` for multiple IDs.
   - `ProductContext` updates state and `localStorage` via `useLocalStorage`.

2. **Search and Filter**:
   - `SearchFilters` updates `filters` in `ProductContext` via `setFilters`.
   - `ProductContext` computes `filteredProducts` using `useMemo` based on `filters`.
   - `ProductDisplay` renders `filteredProducts`.

3. **Notifications**:
   - `ProductForm`, `ProductDisplay`, and `BulkDeletePage` trigger `toast.success` for user feedback.
   - `ProductDisplay` uses interactive toasts for undo.

**Diagram** (simplified):
```
User -> ProductForm -> ProductContext -> localStorage
     -> SearchFilters -> ProductContext -> ProductDisplay
     -> ProductDisplay -> ProductContext -> localStorage
     -> BulkDeletePage -> ProductContext -> localStorage
```

## Testing Strategy

- **Scope**: Focused on `ProductForm` with tests for rendering, validation, submission, edit mode, and error handling.
- **Tools**: Jest with `ts-jest`, React Testing Library, and `@testing-library/jest-dom`.
- **Mocks**:
  - `localStorage` mocked to simulate persistence.
  - `react-toastify` mocked to verify notifications.
  - `ProductContext` mocked to isolate component logic.
- **Setup**: `src/setupTests.ts` extends Jest matchers.
- **Coverage**: High branch and line coverage for `ProductForm`.

**Example**:
```tsx
// src/components/forms/__tests__/ProductForm.test.tsx
it('should prevent submission with invalid data', async () => {
  const user = userEvent.setup();
  renderWithContext(<ProductForm />);
  await user.type(screen.getByLabelText(/product name/i), 'a');
  fireEvent.click(screen.getByText(/add product/i));
  expect(mockContext.addProduct).not.toHaveBeenCalled();
  expect(screen.getByText(/name must be 3-50 characters/i)).toBeInTheDocument();
});
```
